# Trusted Blinding


Web app with four parts:
1. reverse proxy (Go)
2. backend (node.js)
3. signer (python)
4. db (postgres)

Users can register, login, set their configs (github username and key name), and add a "poem".

Poem is signed by the backend app using "blind RSA" protocol from [RFC 9474](https://www.rfc-editor.org/rfc/rfc9474.html):
1. user sends poem to sign
2. backend adds author to it
3. backend "blinds" the modified poem and sends back to users
4. user blindly signs with his/her private key (not knowing what is being signed)
5. user returns blinded signature to server
6. server finalizes the protocol producing signature
7. the signature verifies the modified poem with usual RSA signature verification

The goal of the protocol is that:
* user (private key owner) does not know what the message (modified poem) is being signed
* server (creator of message) learns nothing about the private key


Note that "signer" app name is a bit misleading. The **backend** does RSA signing, the **signer** signs poems by adding an author (like a hand-written signature).

Now, **there are four vulnerabilities** in the challenge.

1. In the signer app, user have to send "type" value that is python `int` but doesn't have any numbers
	* numbers are filter in both proxy and backend
	* the "type" is validated in signer by calling `int(type_from_the_user)`
	* solution is to send specific unicode characters that python will interpret as int

2. User have to access the `/admin/config` endpoint
	* access to the endpoint is restricted by proxy
	* solution is to exploit Go's [Opaque URL](https://pkg.go.dev/net/url#URL)

3. Format string injection in python (signer app)
	* user have to load the flag into the poem using this vulnerability
	* exploitation is prevented by the proxy; it filters {} characters
	* solution is to exploit JSON parsing differences

4. Finally, user have to exploit crypto
	* set "type" to a non-zero number (1)
	* configure the backend to use deterministic RSA variant (using `/admin/config` endpoint) (2)
	* do the format string attack (3)
	* exploit the crypto protocol to learn the modified poem (and so the flag)
	* the crypto itself is not that tricky (basic math only), but not very trivial


## Important / What may go wrong

1. Important configs are in the **.env file**
	* in production: copy `env.sample` to `.env` and update the stuff in there
	* file is used by docker-composer
	* it contains flags and some other secrets, as well as hosts and ports for services
	* **make sure to update all secrets in production!**

2. Users must be allowed to connect **only to the proxy** and no other service

3. The proxy must be **reachable directly**, not through cloudflare, nginx etc
	* this is required to exploit flag2
	* I added self-signed SSL cert in the proxy (autogenerated)
	* if DoS then spin up more instances; if somebody stil DoS us then maybe handle the problem personally (it's an on-site, right?). But I don't anticipate much problems with the proxy, just FYI 

4. The backend gets public keys from GitHub. **GitHub rate limitting** may hit us in the worst case
	* the key is pulled in the `/api/user/config` endpoint
	* If we are blocked by GH, then solver would print something like "HTTP error from GitHub! status: 403" (or 429)
	* **that would make all challenges not solvable**
	* I added per-user and per-ip rate limitting to backend, so we should not hit the rate limit
		* it is in `backend/index.ts`, configurable with `RATE_LIMIT_IP` envvar
	* Backend **should be authenticated** in GitHub: add GitHub auth token to .env in production (with "SSH signing keys" read-only permission)
	* Error 401 from github means that the configured token is invalid
	* If we hit rate limit with the token configured, then tmp fix is to use token from a new GH user

5. I am not sure about postgres configuration in docker-compose.yml.
	* Should work, but maybe the volume should be configured differently.
	* In backed/index.ts the app may drop the table on startup, but I disabled that.
	* To drop DB manually just do `docker-compose down --volumes`

6. All files from `./src` directory should be available to players, including .env with sample values and docker compose.

7. backend should be more async. Let's hope it won't be too slow.

Not important but FYI: there is a bug in [RSA PSS encoding library](https://github.com/bdauvergne/python-pkcs1/blob/2492f80b3a72aafd5b0045b5d40bd9adddc14d22/pkcs1/mgf.py#L5) that I use in solver. I reported it to upstream.


