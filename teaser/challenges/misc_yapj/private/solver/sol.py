(lt := (s := (t := ().__class__).__name__).split().__class__).__dict__ == t.__class__(
    s,
    (),
    (
        dt := (
            d := (
                met := lambda d, k: lt((
                    k := lt(k).pop(),
                    l := lt(d.items()),
                    (matc := lambda: lt((keymet:=lt(l.pop()), ret:=keymet.pop(), (k)in(keymet.pop())and(ret)or(matc()))).pop())()
                )).pop()
            ).__annotations__
        ).__class__
    )(
        __eq__=lambda a, o: o.__ior__(
            (
                (
                    d.keys.__name__,
                    lambda l: (
                        sbcls := met(t.__class__.__dict__, dt(bclasses__=()))(t),
                        name := lt(dt(codec=())).pop().title(),
                        pearl := (matc := lambda: ((name)in(ret:=sbcls.pop()).__name__)and(ret)or(matc()))().__repr__,
                        blobals := met(pearl.__class__.__dict__, dt(lobals__=())),
                        bet := met(dt(__set__=()).__ior__(blobals.__class__.__dict__), dt(et__=())),
                        blobals := bet(blobals, pearl),
                        bltns := met(blobals, dt(iltins__=())),
                        imp := met(bltns, dt(__import__=())),
                        imp(met.__code__.__class__.__name__).interact()
                    ),
                ),
            )
        )
    )
)()

# multiple expressions: lt((e1,e2,e3)).pop()
# 'strings' as dt(some_string=())
dict([])
